# 100 Days Of ML Code - Activity Log



### Day 0: July 29th, 2018

**Today's Progress**:

Learned about hyperparameter tuning, which entails changing the parameters of a machine learning model, as opposed to making changes to the underlying data.  In this case, was looking at the k-value in a KNN model (see next line).

Worked through exercises to optimize hyperparamters, specifically in a k-nearest-neighbors model (optimizing the k-value by using grid search).

Next, learned about using holdout validation, a process involving splitting your dataset into a 50% train and 50% test set, generating predictions, calculating errors, switching the train and test set, repeating earlier steps, and then averaging your errors.

**Thoughts:** 

The hyperparameter tuning using grid search is pretty quick, easy, and efficient.  I enjoyed learning about it.  However, throughout the exercises, I had to revisit a couple concepts including looping through dictionaries and using the Python built-in function 'enumerate'.

This was my first exposure to holdout validation, which is a pretty handy concept.  I'm looking forward to learning more about this and applying to some other "price prediction" datasets.

**Link to work:** https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day0_knn.py



### Day 1: July 30th, 2018

**Today's Progress**:

Learned about the modules KFold and cross_val_score, both from Python's Scikit-Learn library.  

Worked on completing the Dataquest Machine Learning Fundamentals course by spending an hour on the guided project, Predicting Car Prices.  I will post the completed project once I make it all the way through.  One thing I try to do with most of these guided projects is to create a template that can be used for other similar efforts.

I also signed up for the following Kaggle competition : https://www.kaggle.com/c/new-york-city-taxi-fare-prediction/discussion/62146
And.... the associated Google Cloud ML Course on Coursera: https://www.coursera.org/specializations/machine-learning-tensorflow-gcp?utm_source=googlecloud&utm_medium=institutions&utm_campaign=kaggle_competition_email

Lastly, I worked through Day 9 of HackerRank's '30 Days of Code' challenge.  Today entailed using a simple recursive function to calculate a factorial of an integer.  Powerful technique, simple implementation in Python.  Link is provided below.  

It's going to be a lottttttt to keep up with all of these things over the next 100 days, but I couldn't be more excited to learn and grind.

**Thoughts:** 

One thing I'm consistently reminded of as I go through various exercises and guided projects is how important knowing how to clean your data is.  Data is inherently "unclean" from an analytics perspective, and it takes significant effort to get your dataframe into a format where you COULD apply a machine learning algorithm to it.  I imagine it's a topic I'm going to have to come back to again and again.

**Link to work:** https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day1_factorial.py



### Day 2: July 31st, 2018

**Today's Progress**:

Worked through HackerRank's Day 10 Challenge, counting the maximum number of 1's in a binary representation of some int.  This was a good little challenge, and I took the longer route to ensure I understood every step.  You can see the link to my work below.

I also completed Dataquest's Machine Learning Fundamentals course including a project to predict car prices.  Link to this is also below.

I will wrap up the day by working through some more of Google Cloud's ML Course.

**Thoughts:** 

One of the first things I did today was decided to make a change to my approach in terms of studying.  Although I'm generally putting between 3-4 hours a day, I want to be sure I'm hitting certain things daily.  As such, I'm going to always start my day with a single HackerRank challenge.  That will ensure I always have something that I can share and that I'm getting the coding synapses firing.  After HackerRank, I'll ensure I get at least 1% of my Dataquest Data Scientist Path completed.  Lastly, I'll spend the rest of my time doing the Google Cloud Machine Learning Course and Kaggle Taxi Fare Prediction Competition.

**Link to work:** 
https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day2_binary.py

**Link to work 2 (Dataquest Project):**
https://dananomics.com/portfolio/predicting-car-prices/



### Day 3: August 1st, 2018

**Today's Progress**:
Started the day working through HackerRanks "30 Days of Code" Day 11 challenge on 2D Arrays.  More specifically, the task was to take a 6 x 6 2D array, and find the largest sum of all hourglass shapes.  This was great practice for much of the HackerRank challenges leading up to it, reinforcing the concepts of referencing by index, loops, and finding maximum values.  You can see the link to my solution below.

Next, I dug into Dataquest's Calculus for Machine Learning course, which begins with a discussion of "rate of change" and the concept of a secant line (which I imagine will soon translate to a discussion on tangents and derivatives).

I might get a small amount more than this done today, but will call it a little earlier than usual.  I still got around 2 hours of studying in, which I feel okay about.

**Thoughts:** 
Reflecting on the last few months, and also understanding how I'm approaching things going forward, I can't help but feel extremely optimistic that I've been making good progress and will be making great progress going forward.  It's been a lot of fun to feel certain synapses in my brain fire in new ways and for algorithmic thinking to start seeming more natural.  

In the world of Computer Science, and the exploding disciplines of Data Science and Machine Learning, one of the biggest appeals to me is that you can never master it.  To be fair, you can get really good.  But, just as you're getting really good, technology is still evolving.  New paradigms are coming into existence, new software and hardware stacks, new languages.  It is now and has been evident to me for some time that I never want to stop this journey.  

I'm loving every minute!

**Link to work:** 
https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day3_2dArray.py



### Day 4: August 2nd, 2018

**Today's Progress**:
Started out with Day 12 of HackerRank's "30 Days of Code" challenge, which dealt with class and inheritance.  This is one of those topics, that when you're getting started, seems pretty abstract and can be a little bit challenging to grasp.  However, the power of class inheritance in object-oriented programming cannot be overstated.  Having classes and sub-classes saves you tons of time writing the same functions, methods and the like over and over.  Link to my solution is below.

I'm getting my progress tracking out of the way now, but I do expect to spend another hour working on Dataquest's Linear Algebra for Machine Learning course.  

**Thoughts:** 
Yesterday was a bit of a challenge from a motivational standpoint.  I got through quite a bit of material, but felt like I was having to "bite down on the mouth guard" (to borrow a sports saying) to keep going.  It's important for me to remember that it's okay to have those days, and to have days where I meet my minimal commitment of one hour.  Burnout is a real thing when you're pouring everything you have into something.  I've dealth with it in sports, in academia, and just about every other facet of life.  It's natural, and it passes.  As such, today I'm going to wrap things up at a reasonable time, spend time with my wife, and allow my brain a chance to digest much of the material I've poured into it over the last week or so. 

**Link to work:** 
https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day4_inheritance.py



### Day 5: August 3rd, 2018

**Today's Progress**:
Today, I kicked things off with HackerRank's Day 12 of the 30 Days of Code.  The challenge today had to do with Abstract Classes, which involves creating a class, that cannot be instantiated, but whose properties and methods are then extended to a subslcass, which can be instantiated (say, what?!)  See thoughts below in "Thoughts" section.

Next, I continued working on Dataquest's Linear Algebra for Machine Learning course.  Specifically, worked on getting matrices into row reduced echelon form (1's along diagonal from top left to bottom right and 0's elsewhere), using Gaussian Elimination (leveraging row operations to get matrix into desired form).

I also plan to get some of the Coursera/Google Cloud ML course in over the course of the day.

I'm at 2.5 hours of study so far today, which is a good way to start my morning, and kick off my work day.

**Thoughts:** 
Continuing on with my "say, what?!" comment above, this was a pretty straight-forward challenge for an all-things-not-straight-forward concept.  I had to do quite a bit of reading about the purpose for using an Abstract Base Class (ABC) in Python, and came to this conclusion: the primary goal is to ensure what can be considered certain "standards" on the subclasses.  For example, all attributes and methods must be defined in the subclass.  This can help you avoid overlooking certain things you need your subclass to do.  Really interesting and seemingly valuable concept, primarily when you are coding at scale (many subclasses per ABC).  However, am I missing anything here?  Would love to hear a "layman's terms" explanation of this concept.

With regards to the linear algegbra, I didn't realize how much of this content has slipped my mind over the years since my Mathematical Economics courses.  Revisiting this material really reinforces that how I'm approaching my learning, by going through specializations/tracks, is a great way to do it.  Reason being, even if you have to revisit topics you already "know," this really helps solidify them and serves as a great refresher. 

**Link to work:** 
https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day5_abstractClasses.py



### Day 6: August 4th, 2018

**Today's Progress**:
Got Day 6 of the 100 Days of ML Challenge started with HackerRank's "30 Days of Code" Day 14 Scope challenge.  This challenge involved creating a class method that references instance variables, and computing the maximum difference between any 2 integers in a list.  See "Link to work" below for solution.

Next, dove back into Dataquest's 'Linear Algebra for Machine Learning' course.  Worked with matrix-vector operations, specifically using the numpy.dot method to multiply matrices by vectors.  Finished the day solving systems of equations by using matrix inversion (see "Link to work" below).  If you're familiar with solving systems of equations using this method, you know it's enough to make you want to close your computer and leave the house... (just kidding, sort of)

So, being a nice day here in Denver, that's what I'm going to do.  Cheers everyone.

I'll be back at it tomorrow with a fresh mind and energy.

**Thoughts:** 
Object-oriented programming is a very powerful thing, and can feel a bit overwhelming at times.  Class inheritance, instance and class methods, super(), metaclass... the terms alone are enough to make your head spin.  However, there is one thing that makes me feel better about my ability to thoroughly grasp these concepts over time, and that is, I am leaps and bounds beyond where I was when I started programming, and even from a couple months back.

A saying that I often think of during the more grueling days is from the one and only Dwayne "The Rock" Johnson.  He says, “Success isn’t always about ‘Greatness’, it’s about consistency. Consistent, hard work gains success. Greatness will come.”  I've noticed with anything you are trying to learn and get better at in life, the way you do that is BY SHOWING UP AND BEING ENGAGED.  Even on an off day, you can still watch a video or read an article having to do with whatever it is your trying to learn.

I've mentioned before, that it's been fun to notice certain concepts which once I couldn't grasp become much more palatable over time, and even to where I feel I could explain them to someone else.  The journey is long from over, but it's already been really gratifiying.

**Link to work:** 
1) HackerRank: https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day6_scope.py
2) Dataquest: https://github.com/danahagist/100_Days_Of_ML_Code/blob/master/day6_matrixInversion.py


